using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Diagnostics;
using System.Text;

namespace AWise.SepCsvSourceGenerator.Analyzer;

internal sealed class Emitter
{
    private readonly StringBuilder _builder = new();
    private int _indentLevel = 0;

    private void IncreaseIndent()
    {
        _indentLevel++;
    }

    private void DecreaseIndent()
    {
        Debug.Assert(_indentLevel > 0, "Indent level should not be negative.");
        _indentLevel--;
    }

    private void AppendLine(string line)
    {
        if (line.Length > 0)
        {
            for (int i = 0; i < _indentLevel; i++)
            {
                _builder.Append("    ");
            }
        }
        _builder.AppendLine(line);
    }

    public string? Emit(INamedTypeSymbol containingClassSymbol, List<CsvMethodDefinition> methodsToGenerate, CancellationToken cancellationToken)
    {
        _builder.Clear();
        AppendLine("// <auto-generated/>");
        AppendLine("#nullable enable");
        AppendLine("using nietras.SeparatedValues;");
        AppendLine("using System.Globalization;");
        AppendLine("using System.Runtime.CompilerServices;");
        AppendLine("");

        string? namespaceName = containingClassSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : containingClassSymbol.ContainingNamespace.ToDisplayString();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            AppendLine($"namespace {namespaceName}");
            AppendLine("{");
            IncreaseIndent();
        }

        var classStack = new Stack<INamedTypeSymbol>();
        var currentClass = containingClassSymbol;
        while (currentClass != null)
        {
            classStack.Push(currentClass);
            currentClass = currentClass.ContainingType;
        }

        while (classStack.Count > 0)
        {
            var classToDeclare = classStack.Pop();
            var line = new StringBuilder();
            line.Append(SyntaxFacts.GetText(classToDeclare.DeclaredAccessibility)).Append(" partial ")
                   .Append(classToDeclare.IsRecord ? "record " : "") // Handle records
                   .Append(classToDeclare.TypeKind.ToString().ToLowerInvariant()).Append(' ') // class, struct, interface
                   .Append(classToDeclare.Name);
            if (classToDeclare.TypeParameters.Any())
            {
                line.Append('<').Append(string.Join(", ", classToDeclare.TypeParameters.Select(tp => tp.Name))).Append('>');
            }
            AppendLine(line.ToString());
            AppendLine("{");
            IncreaseIndent();
        }


        foreach (var methodDef in methodsToGenerate)
        {
            cancellationToken.ThrowIfCancellationRequested();
            GenerateMethod(methodDef);
        }

        // Close class and namespace braces
        currentClass = containingClassSymbol;
        while (currentClass != null)
        {
            DecreaseIndent();
            AppendLine("}");
            currentClass = currentClass.ContainingType;
        }

        if (!string.IsNullOrEmpty(namespaceName))
        {
            DecreaseIndent();
            AppendLine("}");
        }

        return _builder.ToString();
    }

    private void GenerateMethod(CsvMethodDefinition methodDef)
    {
        var itemTypeName = methodDef.ItemTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Build the method modifiers by inspecting the symbol
        var modifiers = new List<string>
            {
                SyntaxFacts.GetText(methodDef.MethodSymbol.DeclaredAccessibility)
            };
        if (methodDef.MethodSymbol.IsStatic)
        {
            modifiers.Add("static");
        }
        if (methodDef.MethodSymbol.IsOverride)
        {
            modifiers.Add("override");
        }
        // The 'async' keyword is not a modifier in the traditional sense for symbols, so we add it manually.
        if (methodDef.IsAsync)
        {
            modifiers.Add("async");
        }
        modifiers.Add("partial");

        string returnType = methodDef.IsAsync
            ? $"global::System.Collections.Generic.IAsyncEnumerable<{itemTypeName}>"
            : $"global::System.Collections.Generic.IEnumerable<{itemTypeName}>";

        var line = new StringBuilder();
        line.Append(string.Join(" ", modifiers))
                .Append($" {returnType} {methodDef.MethodSymbol.Name}(SepReader reader, ")
                .Append(methodDef.IsAsync ? "[EnumeratorCancellation] " : "")
                .Append("global::System.Threading.CancellationToken ct)");
        AppendLine(line.ToString());
        AppendLine("{");
        IncreaseIndent();

        // Declare index variables
        foreach (var prop in methodDef.PropertiesToParse)
        {
            AppendLine($"int {prop.Name}Ndx;");
        }
        AppendLine("");

        // Get header indices
        foreach (var prop in methodDef.PropertiesToParse)
        {
            AppendLine($"if (!reader.Header.TryIndexOf(\"{prop.HeaderName}\", out {prop.Name}Ndx))");
            AppendLine("{");
            IncreaseIndent();
            if (prop.IsRequiredMember)
            {
                AppendLine($"throw new global::System.ArgumentException($\"Missing required column '{prop.HeaderName}' for required property '{prop.Name}'.\");");
            }
            else
            {
                AppendLine($"{prop.Name}Ndx = -1;");
            }
            DecreaseIndent();
            AppendLine("}");
        }
        AppendLine("");

        if (methodDef.IsAsync)
        {
            AppendLine("await foreach (SepReader.Row row in reader");
            // The ConfigureAwait only works in .NET 10 and later: https://github.com/dotnet/runtime/issues/112007
            IncreaseIndent();
            AppendLine("#if NET10_0_OR_GREATER");
            AppendLine(".WithCancellation(ct).ConfigureAwait(false)");
            AppendLine("#endif");
            DecreaseIndent();
            AppendLine(")");
        }
        else
        {
            AppendLine("foreach (SepReader.Row row in reader)");
        }

        AppendLine("{");
        IncreaseIndent();
        AppendLine("ct.ThrowIfCancellationRequested();");
        AppendLine("");

        var retLine = new StringBuilder();
        retLine.Append($"{itemTypeName} ret = new {itemTypeName}()");

        var requiredProps = methodDef.PropertiesToParse.Where(p => p.IsRequiredMember).ToList();
        if (requiredProps.Count != 0)
        {
            AppendLine(retLine.ToString());
            AppendLine("{");
            IncreaseIndent();
            for (int i = 0; i < requiredProps.Count; i++)
            {
                var prop = requiredProps[i];
                AppendLine($"{prop.Name} = {GetParseExpression(prop, $"{prop.Name}Ndx")}" + (i < requiredProps.Count - 1 ? "," : ""));
            }
            DecreaseIndent();
            AppendLine("};");
        }
        else
        {
            retLine.Append(';');
            AppendLine(retLine.ToString());
        }


        foreach (var prop in methodDef.PropertiesToParse.Where(p => !p.IsRequiredMember))
        {
            AppendLine($"if ({prop.Name}Ndx != -1)");
            AppendLine("{");
            IncreaseIndent();
            AppendLine($"ret.{prop.Name} = {GetParseExpression(prop, $"{prop.Name}Ndx")};");
            DecreaseIndent();
            AppendLine("}");
        }

        AppendLine("yield return ret;");
        DecreaseIndent();
        AppendLine("}"); // end foreach
        DecreaseIndent();
        AppendLine("}"); // end method
    }

    private static string GetParseExpression(CsvPropertyDefinition prop, string indexVarName)
    {
        string spanAccess = $"row[{indexVarName}].Span";
        return prop.Kind switch
        {
            CsvPropertyKind.DateOrTime => $"{prop.UnderlyingTypeName}.ParseExact({spanAccess}, \"{prop.DateFormat}\", CultureInfo.InvariantCulture)",
            CsvPropertyKind.String => $"{spanAccess}.ToString()",
            CsvPropertyKind.Enum => $"global::System.Enum.Parse<{prop.UnderlyingTypeName}>({spanAccess})",
            CsvPropertyKind.SpanParsable => $"{prop.UnderlyingTypeName}.Parse({spanAccess}, CultureInfo.InvariantCulture)",
            _ => throw new InvalidOperationException()
        };
    }
}
