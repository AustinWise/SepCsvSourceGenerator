using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Diagnostics;
using System.Text;

namespace AWise.SepCsvSourceGenerator.Analyzer;

internal sealed class Emitter
{
    private readonly StringBuilder _builder = new();
    private int _indentLevel = 0;

    private void IncreaseIndent()
    {
        _indentLevel++;
    }

    private void DecreaseIndent()
    {
        Debug.Assert(_indentLevel > 0, "Indent level should not be negative.");
        _indentLevel--;
    }

    private void AppendLine(string line)
    {
        if (line.Length > 0)
        {
            for (int i = 0; i < _indentLevel; i++)
            {
                _builder.Append("    ");
            }
        }
        _builder.AppendLine(line);
    }

    public string? Emit(INamedTypeSymbol containingClassSymbol, List<CsvMethodDefinition> methodsToGenerate, CancellationToken cancellationToken)
    {
        _builder.Clear();
        AppendLine("// <auto-generated/>");
        AppendLine("#nullable enable");
        AppendLine("using nietras.SeparatedValues;");
        AppendLine("using System.Globalization;");
        AppendLine("using System.Runtime.CompilerServices;");
        AppendLine("");

        string? namespaceName = containingClassSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : containingClassSymbol.ContainingNamespace.ToDisplayString();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            AppendLine($"namespace {namespaceName}");
            AppendLine("{");
            IncreaseIndent();
        }

        var classStack = new Stack<INamedTypeSymbol>();
        var currentClass = containingClassSymbol;
        while (currentClass != null)
        {
            classStack.Push(currentClass);
            currentClass = currentClass.ContainingType;
        }

        while (classStack.Count > 0)
        {
            var classToDeclare = classStack.Pop();
            var line = new StringBuilder();
            line.Append(SyntaxFacts.GetText(classToDeclare.DeclaredAccessibility)).Append(" partial ")
                   .Append(classToDeclare.IsRecord ? "record " : "") // Handle records
                   .Append(classToDeclare.TypeKind.ToString().ToLowerInvariant()).Append(' ') // class, struct, interface
                   .Append(classToDeclare.Name);
            if (classToDeclare.TypeParameters.Any())
            {
                line.Append('<').Append(string.Join(", ", classToDeclare.TypeParameters.Select(tp => tp.Name))).Append('>');
            }
            AppendLine(line.ToString());
            AppendLine("{");
            IncreaseIndent();
        }


        foreach (var methodDef in methodsToGenerate)
        {
            cancellationToken.ThrowIfCancellationRequested();
            GenerateMethod(methodDef);
        }

        // Close class and namespace braces
        currentClass = containingClassSymbol;
        while (currentClass != null)
        {
            DecreaseIndent();
            AppendLine("}");
            currentClass = currentClass.ContainingType;
        }

        if (!string.IsNullOrEmpty(namespaceName))
        {
            DecreaseIndent();
            AppendLine("}");
        }

        return _builder.ToString();
    }

    private void GenerateMethod(CsvMethodDefinition methodDef)
    {
        var itemTypeName = methodDef.ItemTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Build the method modifiers by inspecting the symbol
        var modifiers = new List<string>
            {
                SyntaxFacts.GetText(methodDef.MethodSymbol.DeclaredAccessibility)
            };
        if (methodDef.MethodSymbol.IsStatic)
        {
            modifiers.Add("static");
        }
        if (methodDef.MethodSymbol.IsOverride)
        {
            modifiers.Add("override");
        }
        // The 'async' keyword is not a modifier in the traditional sense for symbols, so we add it manually.
        if (methodDef.IsAsync)
        {
            modifiers.Add("async");
        }
        modifiers.Add("partial");

        string returnType = methodDef.IsAsync
            ? $"global::System.Collections.Generic.IAsyncEnumerable<{itemTypeName}>"
            : $"global::System.Collections.Generic.IEnumerable<{itemTypeName}>";

        var line = new StringBuilder();
        line.Append(string.Join(" ", modifiers))
                .Append($" {returnType} {methodDef.MethodSymbol.Name}(SepReader {methodDef.ReaderParameterName}");
        if (methodDef.CancellationTokenParameterName is not null)
        {
            line.Append(", ");
            if (methodDef.IsAsync)
            {
                line.Append("[EnumeratorCancellation] ");
            }
            line.Append($"global::System.Threading.CancellationToken {methodDef.CancellationTokenParameterName}");
        }
        line.Append(')');
        AppendLine(line.ToString());
        AppendLine("{");
        IncreaseIndent();

        // Declare index variables
        foreach (var prop in methodDef.PropertiesToParse)
        {
            AppendLine($"int {prop.Name}Ndx;");
        }
        AppendLine("");

        // Get header indices
        foreach (var prop in methodDef.PropertiesToParse)
        {
            var tryFindIndex = string.Join(" || ", prop.HeaderNames.Select(h => $"{methodDef.ReaderParameterName}.Header.TryIndexOf(\"{h}\", out {prop.Name}Ndx)"));
            if (prop.HeaderNames.Length == 1)
            {
                AppendLine($"if (!{tryFindIndex})");
            }
            else
            {
                AppendLine($"if (!({tryFindIndex}))");
            }
            AppendLine("{");
            IncreaseIndent();
            if (prop.IsRequiredMember)
            {
                if (prop.HeaderNames.Length == 1)
                {
                    AppendLine($"throw new global::System.ArgumentException($\"Missing required column '{prop.HeaderNames[0]}' for required property '{prop.Name}'.\");");
                }
                else
                {
                    var headerNames = string.Join("', '", prop.HeaderNames);
                    AppendLine($"throw new global::System.ArgumentException($\"Missing required column with any of the following names: '{headerNames}' for required property '{prop.Name}'.\");");
                }
            }
            else
            {
                AppendLine($"{prop.Name}Ndx = -1;");
            }
            DecreaseIndent();
            AppendLine("}");
        }
        AppendLine("");

        if (methodDef.IsAsync)
        {
            AppendLine($"await foreach (SepReader.Row row in {methodDef.ReaderParameterName}");
            // The ConfigureAwait only works in .NET 10 and later: https://github.com/dotnet/runtime/issues/112007
            IncreaseIndent();
            AppendLine("#if NET10_0_OR_GREATER");
            if (methodDef.CancellationTokenParameterName is not null)
            {
                AppendLine($".WithCancellation({methodDef.CancellationTokenParameterName}).ConfigureAwait(false)");
            }
            else
            {
                AppendLine(".ConfigureAwait(false)");
            }
            AppendLine("#endif");
            DecreaseIndent();
            AppendLine(")");
        }
        else
        {
            AppendLine($"foreach (SepReader.Row row in {methodDef.ReaderParameterName})");
        }

        AppendLine("{");
        IncreaseIndent();
        if (methodDef.CancellationTokenParameterName is not null)
        {
            AppendLine($"{methodDef.CancellationTokenParameterName}.ThrowIfCancellationRequested();");
        }
        AppendLine("");

        AppendLine($"{itemTypeName} ret = new {itemTypeName}()");
        AppendLine("{");
        IncreaseIndent();
        foreach (var prop in methodDef.PropertiesToParse.Where(MustAssignInObjectInitializer))
        {
            var propLine = new StringBuilder();
            propLine.Append(prop.Name).Append(" = ");
            if (!prop.IsRequiredMember)
            {
                propLine.Append($"({prop.Name}Ndx != -1) ? ");
            }
            propLine.Append(GetParseExpression(prop, $"{prop.Name}Ndx"));
            if (!prop.IsRequiredMember)
            {
                propLine.Append($" : default");
            }
            propLine.Append(',');
            AppendLine(propLine.ToString());
        }
        DecreaseIndent();
        AppendLine("};");

        foreach (var prop in methodDef.PropertiesToParse.Where(p => !MustAssignInObjectInitializer(p)))
        {
            AppendLine($"if ({prop.Name}Ndx != -1)");
            AppendLine("{");
            IncreaseIndent();
            AppendLine($"ret.{prop.Name} = {GetParseExpression(prop, $"{prop.Name}Ndx")};");
            DecreaseIndent();
            AppendLine("}");
        }

        AppendLine("yield return ret;");
        DecreaseIndent();
        AppendLine("}"); // end foreach
        DecreaseIndent();
        AppendLine("}"); // end method
    }

    private static bool MustAssignInObjectInitializer(CsvPropertyDefinition def)
    {
        return def.IsInitOnly || def.IsRequiredMember;
    }

    private static string GetParseExpression(CsvPropertyDefinition prop, string indexVarName)
    {
        string spanAccess = $"row[{indexVarName}].Span";
        return prop.Kind switch
        {
            CsvPropertyKind.DateOrTime => $"{prop.UnderlyingTypeName}.ParseExact({spanAccess}, \"{prop.DateFormat}\", CultureInfo.InvariantCulture)",
            CsvPropertyKind.String => $"{spanAccess}.ToString()",
            CsvPropertyKind.Enum => $"global::System.Enum.Parse<{prop.UnderlyingTypeName}>({spanAccess})",
            CsvPropertyKind.SpanParsable => $"{prop.UnderlyingTypeName}.Parse({spanAccess}, CultureInfo.InvariantCulture)",
            _ => throw new InvalidOperationException()
        };
    }
}
