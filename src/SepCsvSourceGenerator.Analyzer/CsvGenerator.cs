using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Xml.Linq;

namespace SepCsvSourceGenerator;

[Generator]
public class CsvGenerator : IIncrementalGenerator
{
    private const string GenerateCsvParserAttributeName = "SepCsvSourceGenerator.GenerateCsvParserAttribute";
    private const string CsvHeaderNameAttributeName = "SepCsvSourceGenerator.CsvHeaderNameAttribute";
    private const string CsvDateFormatAttributeName = "SepCsvSourceGenerator.CsvDateFormatAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<MethodDeclarationSyntax> methodDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(GenerateCsvParserAttributeName,
                predicate: static (s, _) => s is MethodDeclarationSyntax,
                transform: static (ctx, _) => (MethodDeclarationSyntax)ctx.TargetNode)
            .Where(static m => m is not null)!;

        IncrementalValueProvider<(Compilation, ImmutableArray<MethodDeclarationSyntax>)> compilationAndMethods =
            context.CompilationProvider.Combine(methodDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndMethods,
            static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    static void Execute(Compilation compilation, ImmutableArray<MethodDeclarationSyntax> methods, SourceProductionContext context)
    {
        foreach (var methodSyntax in methods)
        {
            var semanticModel = compilation.GetSemanticModel(methodSyntax.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(methodSyntax) is not IMethodSymbol methodSymbol)
            {
                continue;
            }

            if (methodSymbol.ContainingType is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            string generatedSource = GenerateParserSourceForMethod(compilation, classSymbol, methodSymbol, context);
            if (!string.IsNullOrEmpty(generatedSource))
            {
                context.AddSource($"{classSymbol.Name}_{methodSymbol.Name}.g.cs", SourceText.From(generatedSource, Encoding.UTF8));
            }
        }
    }

    static string GenerateParserSourceForMethod(Compilation compilation, INamedTypeSymbol classSymbol, IMethodSymbol methodSymbol, SourceProductionContext context)
    {
        AttributeData? generateCsvParserAttributeData = methodSymbol.GetAttributes().FirstOrDefault(ad => ad.AttributeClass?.ToDisplayString() == GenerateCsvParserAttributeName);
        bool includeFields = false;
        if (generateCsvParserAttributeData != null)
        {
            foreach (var namedArg in generateCsvParserAttributeData.NamedArguments)
            {
                if (namedArg.Key == "IncludeFields" && namedArg.Value.Value is bool b)
                {
                    includeFields = b;
                    break;
                }
            }
        }

        var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        var source = new StringBuilder();
        source.AppendLine("// <auto-generated/>");
        source.AppendLine("#nullable enable");
        source.AppendLine("using System;");
        source.AppendLine("using System.Collections.Generic;");
        source.AppendLine("using System.Globalization;");
        source.AppendLine("using System.Runtime.CompilerServices;");
        source.AppendLine("using nietras.SeparatedValues;");
        source.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            source.AppendLine($"namespace {namespaceName}");
            source.AppendLine("{");
        }

        source.AppendLine($"    partial class {className}");
        source.AppendLine("    {");

        string paramsString = string.Join(", ", methodSymbol.Parameters.Select(p =>
        {
            string paramType = p.Type.ToDisplayString();
            string attrs = p.Type.ToDisplayString() == "System.Threading.CancellationToken" ? "[EnumeratorCancellation] " : "";
            return $"{attrs}{paramType} {p.Name}";
        }));

        source.AppendLine($"        public async static partial {methodSymbol.ReturnType.ToDisplayString()} {methodSymbol.Name}({paramsString})");
        source.AppendLine("        {");

        var membersToMap = GetMappableMembers(classSymbol, includeFields);
        string cancellationTokenName = methodSymbol.Parameters.FirstOrDefault(p => p.Type.ToDisplayString() == "System.Threading.CancellationToken")?.Name ?? "ct"; // Assume 'ct' if not found, though signature should have it
        bool hasCancellationToken = methodSymbol.Parameters.Any(p => p.Type.ToDisplayString() == "System.Threading.CancellationToken");

        foreach (var member in membersToMap)
        {
            source.AppendLine($"            int {ToCamelCase(member.Name)}Ndx;");
        }
        source.AppendLine();

        foreach (var member in membersToMap)
        {
            string csvHeaderName = member.CsvHeaderName ?? member.Name;
            string indexVarName = ToCamelCase(member.Name) + "Ndx";
            source.AppendLine($"            if (!reader.Header.TryIndexOf(\"{csvHeaderName.Replace("\"", "\\\"")}\", out {indexVarName}))");
            source.AppendLine("            {");
            if (member.IsRequired)
            {
                source.AppendLine($"                throw new ArgumentException(\"Missing required column name '{csvHeaderName.Replace("'", "\\'")}'\");");
            }
            else
            {
                source.AppendLine($"                {indexVarName} = -1;");
            }
            source.AppendLine("            }");
        }
        source.AppendLine();

        source.AppendLine("            await foreach (SepReader.Row row in reader)");
        source.AppendLine("            {");
        if (hasCancellationToken)
        {
            source.AppendLine($"                {cancellationTokenName}.ThrowIfCancellationRequested();");
        }
        source.AppendLine();
        source.AppendLine($"                var ret = new {className}()");
        source.AppendLine("                {");

        foreach (var member in membersToMap.Where(m => m.IsRequired))
        {
            string indexVarName = ToCamelCase(member.Name) + "Ndx";
            source.AppendLine($"                    {member.Name} = {GetParsingLogic(member, $"row[{indexVarName}].Span")},");
        }
        source.AppendLine("                };");

        foreach (var member in membersToMap.Where(m => !m.IsRequired))
        {
            bool isSettable = true;
            if (member.OriginalSymbol is IPropertySymbol propSymbol && propSymbol.SetMethod == null)
            {
                isSettable = false;
            }

            if (isSettable)
            {
                string indexVarName = ToCamelCase(member.Name) + "Ndx";
                source.AppendLine($"                if ({indexVarName} != -1)");
                source.AppendLine("                {");
                source.AppendLine($"                    ret.{member.Name} = {GetParsingLogic(member, $"row[{indexVarName}].Span")};");
                source.AppendLine("                }");
            }
        }

        source.AppendLine("                yield return ret;");
        source.AppendLine("            }");
        source.AppendLine("        }");

        source.AppendLine("    }");

        if (!string.IsNullOrEmpty(namespaceName))
        {
            source.AppendLine("}");
        }
        return source.ToString();
    }

    static List<MemberInfo> GetMappableMembers(INamedTypeSymbol classSymbol, bool includeFields)
    {
        var members = new List<MemberInfo>();
        foreach (var memberSymbol in classSymbol.GetMembers())
        {
            if (memberSymbol.IsStatic || memberSymbol.DeclaredAccessibility != Accessibility.Public) continue;
            if (!(memberSymbol.Kind == SymbolKind.Property || (includeFields && memberSymbol.Kind == SymbolKind.Field))) continue;
            if (memberSymbol.IsImplicitlyDeclared && memberSymbol is IFieldSymbol) continue; // Skip backing fields

            string? csvHeaderName = null;
            string? dateFormat = null;

            foreach (var attribute in memberSymbol.GetAttributes())
            {
                if (attribute.AttributeClass?.ToDisplayString() == CsvHeaderNameAttributeName)
                    csvHeaderName = attribute.ConstructorArguments.FirstOrDefault().Value?.ToString();
                else if (attribute.AttributeClass?.ToDisplayString() == CsvDateFormatAttributeName)
                    dateFormat = attribute.ConstructorArguments.FirstOrDefault().Value?.ToString();
            }

            ITypeSymbol memberType = memberSymbol switch { IPropertySymbol p => p.Type, IFieldSymbol f => f.Type, _ => null! };

            members.Add(new MemberInfo
            {
                OriginalSymbol = memberSymbol,
                Name = memberSymbol.Name,
                Type = memberType,
                IsRequired = memberSymbol is IPropertySymbol propSym && propSym.IsRequired,
                CsvHeaderName = csvHeaderName,
                DateFormat = dateFormat
            });
        }
        return members;
    }

    static string GetParsingLogic(MemberInfo member, string spanAccessor)
    {
        ITypeSymbol type = member.Type;
        ITypeSymbol typeForSwitch = (type is INamedTypeSymbol nts && nts.IsValueType && nts.NullableAnnotation == NullableAnnotation.Annotated)
                                 ? nts.TypeArguments.First()
                                 : type;
        string originalTypeName = typeForSwitch.OriginalDefinition.ToDisplayString();

        string parseExpression;
        if (originalTypeName == "System.DateTime")
        {
            string format = member.DateFormat ?? "MM/dd/yyyy"; // Default format from example
            parseExpression = $"DateTime.ParseExact({spanAccessor}, \"{format}\", CultureInfo.InvariantCulture)";
        }
        else // Includes string, string?, and other types (relying on ToString() then assignment)
        {
            parseExpression = $"{spanAccessor}.ToString()";
        }

        if (type is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsValueType && namedTypeSymbol.NullableAnnotation == NullableAnnotation.Annotated && originalTypeName == "System.DateTime")
        {
            return $"({spanAccessor}.IsEmpty ? default({type.ToDisplayString()}) : ({type.ToDisplayString()})({parseExpression}))";
        }
        return parseExpression;
    }

    static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return "val";
        string tempName = name.Replace(" ", ""); // Handle names like "Transaction Date" -> "TransactionDate"
        if (string.IsNullOrEmpty(tempName)) return "val";
        return char.ToLowerInvariant(tempName[0]) + tempName.Substring(1);
    }

    class MemberInfo
    {
        public required ISymbol OriginalSymbol { get; init; }
        public required string Name { get; init; }
        public required ITypeSymbol Type { get; init; }
        public required bool IsRequired { get; init; }
        public string? CsvHeaderName { get; init; }
        public string? DateFormat { get; init; }
    }
}
