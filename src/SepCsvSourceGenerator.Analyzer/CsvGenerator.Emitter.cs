using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace SepCsvSourceGenerator;

public partial class CsvGenerator
{
    internal sealed class Emitter
    {
        private readonly StringBuilder _builder = new(1024);

        public string Emit(IReadOnlyList<CsvMethod> methods, CancellationToken cancellationToken)
        {
            _builder.Clear();
            _builder.AppendLine("// <auto-generated/>");
            _builder.AppendLine("#nullable enable");
            _builder.AppendLine();

            foreach (var method in methods)
            {
                cancellationToken.ThrowIfCancellationRequested();
                EmitMethod(method);
            }

            return _builder.ToString();
        }

        private void EmitMethod(CsvMethod method)
        {
            if (!string.IsNullOrEmpty(method.Namespace))
            {
                _builder.AppendLine($"namespace {method.Namespace}");
                _builder.AppendLine("{");
            }

            _builder.AppendLine($"    partial class {method.ContainingTypeName}");
            _builder.AppendLine("    {");

            // Emit the method implementation
            _builder.AppendLine($"        public static async partial IAsyncEnumerable<{method.ContainingTypeName}> {method.MethodName}(nietras.SeparatedValues.SepReader reader, [System.Runtime.CompilerServices.EnumeratorCancellation] System.Threading.CancellationToken ct = default)");
            _builder.AppendLine("        {");

            // Declare index variables for each property
            foreach (var prop in method.Properties)
            {
                _builder.AppendLine($"            int {prop.PropertyName}Ndx;");
            }
            _builder.AppendLine();

            // Get column indices from header
            foreach (var prop in method.Properties)
            {
                if (prop.IsRequired)
                {
                    _builder.AppendLine($"            if (!reader.Header.TryIndexOf(\"{prop.HeaderName}\", out {prop.PropertyName}Ndx))");
                    _builder.AppendLine($"            {{");
                    _builder.AppendLine($"                throw new System.ArgumentException(\"Missing column name '{prop.HeaderName}'\");");
                    _builder.AppendLine($"            }}");
                }
                else
                {
                    _builder.AppendLine($"            if (!reader.Header.TryIndexOf(\"{prop.HeaderName}\", out {prop.PropertyName}Ndx))");
                    _builder.AppendLine($"            {{");
                    _builder.AppendLine($"                {prop.PropertyName}Ndx = -1;");
                    _builder.AppendLine($"            }}");
                }
            }
            _builder.AppendLine();

            // Process each row
            _builder.AppendLine("            await foreach (var row in reader.ConfigureAwait(false))");
            _builder.AppendLine("            {");
            _builder.AppendLine("                ct.ThrowIfCancellationRequested();");
            _builder.AppendLine();
            _builder.AppendLine($"                var ret = new {method.ContainingTypeName}");
            _builder.AppendLine("                {");

            // Initialize required properties
            foreach (var prop in method.Properties.Where(p => p.IsRequired))
            {
                _builder.AppendLine($"                    {prop.PropertyName} = {GenerateParseExpression(prop, "row", $"{prop.PropertyName}Ndx")},");
            }

            _builder.AppendLine("                };");
            _builder.AppendLine();

            // Initialize optional properties
            foreach (var prop in method.Properties.Where(p => !p.IsRequired))
            {
                _builder.AppendLine($"                if ({prop.PropertyName}Ndx != -1)");
                _builder.AppendLine("                {");
                _builder.AppendLine($"                    ret.{prop.PropertyName} = {GenerateParseExpression(prop, "row", $"{prop.PropertyName}Ndx")};");
                _builder.AppendLine("                }");
            }

            _builder.AppendLine();
            _builder.AppendLine("                yield return ret;");
            _builder.AppendLine("            }");
            _builder.AppendLine("        }");
            _builder.AppendLine("    }");

            if (!string.IsNullOrEmpty(method.Namespace))
            {
                _builder.AppendLine("}");
            }
            _builder.AppendLine();
        }

        private string GenerateParseExpression(CsvProperty prop, string rowVar, string indexVar)
        {
            // Handle DateTime with custom format
            if (prop.TypeName == "System.DateTime" && !string.IsNullOrEmpty(prop.DateFormat))
            {
                return $"System.DateTime.ParseExact({rowVar}[{indexVar}].Span, \"{prop.DateFormat}\", System.Globalization.CultureInfo.InvariantCulture)";
            }

            // Handle string specially (no parsing needed)
            if (prop.TypeName == "string")
            {
                return $"{rowVar}[{indexVar}].Span.ToString()";
            }

            // Handle other types that implement ISpanParsable<T>
            string parseMethod = $"{prop.TypeName}.Parse";
            return $"{parseMethod}({rowVar}[{indexVar}].Span, System.Globalization.CultureInfo.InvariantCulture)";
        }
    }
}