using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Text;

namespace US.AWise.SepCsvSourceGenerator.Analyzer;

public partial class CsvGenerator
{
    internal sealed class Emitter(Action<Diagnostic> reportDiagnostic)
    {
        private readonly Action<Diagnostic> _reportDiagnostic = reportDiagnostic;
        private readonly StringBuilder _builder = new();

        public static string GetHintName(INamedTypeSymbol classSymbol)
        {
            // Create a unique file name, e.g., Namespace.ClassName.CsvGenerator.g.cs
            // Replace invalid filename characters from namespace and class name
            var parts = new List<string>();
            if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                parts.Add(SanitizeFileName(classSymbol.ContainingNamespace.ToDisplayString()));
            }

            var typeHierarchy = new Stack<string>();
            INamedTypeSymbol? current = classSymbol;
            while (current != null)
            {
                typeHierarchy.Push(SanitizeFileName(current.Name));
                current = current.ContainingType;
            }
            parts.AddRange(typeHierarchy);
            return string.Join(".", parts) + ".CsvGenerator.g.cs";
        }

        private static string SanitizeFileName(string name) => name.Replace("<", "_").Replace(">", "_").Replace("?", "_").Replace("*", "_");

        public string? Emit(INamedTypeSymbol containingClassSymbol, List<Parser.CsvMethodDefinition> methodsToGenerate, CancellationToken cancellationToken)
        {
            _builder.Clear();
            _builder.AppendLine("// <auto-generated/>");
            _builder.AppendLine("#nullable enable");
            _builder.AppendLine("using nietras.SeparatedValues;");
            _builder.AppendLine("using System.Globalization;");
            _builder.AppendLine("using System.Runtime.CompilerServices;");
            _builder.AppendLine();

            string? namespaceName = containingClassSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : containingClassSymbol.ContainingNamespace.ToDisplayString();

            if (!string.IsNullOrEmpty(namespaceName))
            {
                _builder.AppendLine($"namespace {namespaceName}");
                _builder.AppendLine("{");
            }

            var classStack = new Stack<INamedTypeSymbol>();
            var currentClass = containingClassSymbol;
            while (currentClass != null)
            {
                classStack.Push(currentClass);
                currentClass = currentClass.ContainingType;
            }

            string indent = string.IsNullOrEmpty(namespaceName) ? "" : "    ";
            while (classStack.Count > 0)
            {
                var classToDeclare = classStack.Pop();
                _builder.Append(indent).Append(SyntaxFacts.GetText(classToDeclare.DeclaredAccessibility)).Append(" partial ")
                       .Append(classToDeclare.IsRecord ? "record " : "") // Handle records
                       .Append(classToDeclare.TypeKind.ToString().ToLowerInvariant()).Append(" ") // class, struct, interface
                       .Append(classToDeclare.Name);
                if (classToDeclare.TypeParameters.Any())
                {
                    _builder.Append("<").Append(string.Join(", ", classToDeclare.TypeParameters.Select(tp => tp.Name))).Append(">");
                }
                _builder.AppendLine();
                _builder.Append(indent).AppendLine("{");
                indent += "    ";
            }


            foreach (var methodDef in methodsToGenerate)
            {
                cancellationToken.ThrowIfCancellationRequested();
                GenerateMethod(methodDef, indent);
            }

            // Close class and namespace braces
            currentClass = containingClassSymbol;
            while (currentClass != null)
            {
                indent = indent.Substring(0, indent.Length - 4);
                _builder.Append(indent).AppendLine("}");
                currentClass = currentClass.ContainingType;
            }

            if (!string.IsNullOrEmpty(namespaceName))
            {
                _builder.AppendLine("}");
            }

            return _builder.ToString();
        }

        private void GenerateMethod(Parser.CsvMethodDefinition methodDef, string baseIndent)
        {
            var itemTypeName = methodDef.ItemTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // Build the method modifiers by inspecting the symbol
            var modifiers = new List<string>();
            modifiers.Add(SyntaxFacts.GetText(methodDef.MethodSymbol.DeclaredAccessibility));
            if (methodDef.MethodSymbol.IsStatic)
            {
                modifiers.Add("static");
            }
            if (methodDef.MethodSymbol.IsOverride)
            {
                modifiers.Add("override");
            }
            // The 'async' keyword is not a modifier in the traditional sense for symbols, so we add it manually.
            modifiers.Add("async");
            modifiers.Add("partial");

            _builder.Append(baseIndent).Append(string.Join(" ", modifiers))
                    .Append($" global::System.Collections.Generic.IAsyncEnumerable<{itemTypeName}> {methodDef.MethodSymbol.Name}(SepReader reader, [EnumeratorCancellation] global::System.Threading.CancellationToken ct)")
                    .AppendLine()
                    .Append(baseIndent).AppendLine("{");

            string indent = baseIndent + "    ";

            // Declare index variables
            foreach (var prop in methodDef.PropertiesToParse)
            {
                _builder.Append(indent).AppendLine($"int {prop.Name}Ndx;");
            }
            _builder.AppendLine();

            // Get header indices
            foreach (var prop in methodDef.PropertiesToParse)
            {
                _builder.Append(indent).AppendLine($"if (!reader.Header.TryIndexOf(\"{prop.HeaderName}\", out {prop.Name}Ndx))");
                _builder.Append(indent).AppendLine("{");
                if (prop.IsRequiredMember)
                {
                    _builder.Append(indent).AppendLine($"    throw new global::System.ArgumentException($\"Missing required column '{prop.HeaderName}' for required member '{itemTypeName}.{prop.Name}'.\");");
                }
                else
                {
                    _builder.Append(indent).AppendLine($"    {prop.Name}Ndx = -1;");
                }
                _builder.Append(indent).AppendLine("}");
            }
            _builder.AppendLine();

            _builder.Append(indent).AppendLine("await foreach (SepReader.Row row in reader");
            // The ConfigureAwait only works in .NET 10 and later: https://github.com/dotnet/runtime/issues/112007
            _builder.Append(indent).AppendLine("#if NET10_0_OR_GREATER");
            _builder.Append(indent).AppendLine(".WithCancellation(ct).ConfigureAwait(false)");
            _builder.Append(indent).AppendLine("#endif");
            _builder.Append(indent).AppendLine(")");

            _builder.Append(indent).AppendLine("{");
            string innerIndent = indent + "    ";
            _builder.Append(innerIndent).AppendLine("ct.ThrowIfCancellationRequested();");
            _builder.AppendLine();

            _builder.Append(innerIndent).Append($"{itemTypeName} ret = new {itemTypeName}()");

            var requiredProps = methodDef.PropertiesToParse.Where(p => p.IsRequiredMember).ToList();
            if (requiredProps.Any())
            {
                _builder.AppendLine();
                _builder.Append(innerIndent).AppendLine("{");
                string initializerIndent = innerIndent + "    ";
                for (int i = 0; i < requiredProps.Count; i++)
                {
                    var prop = requiredProps[i];
                    _builder.Append(initializerIndent).Append($"{prop.Name} = {GetParseExpression(prop, $"{prop.Name}Ndx")}");
                    _builder.AppendLine(i < requiredProps.Count - 1 ? "," : "");
                }
                _builder.Append(innerIndent).AppendLine("};");
            }
            else
            {
                _builder.AppendLine(";"); // Close the new statement if no required initializers
            }


            foreach (var prop in methodDef.PropertiesToParse.Where(p => !p.IsRequiredMember))
            {
                _builder.Append(innerIndent).AppendLine($"if ({prop.Name}Ndx != -1)");
                _builder.Append(innerIndent).AppendLine("{");
                _builder.Append(innerIndent).AppendLine($"    ret.{prop.Name} = {GetParseExpression(prop, $"{prop.Name}Ndx")};");
                _builder.Append(innerIndent).AppendLine("}");
            }

            _builder.Append(innerIndent).AppendLine("yield return ret;");
            _builder.Append(indent).AppendLine("}"); // end foreach
            _builder.Append(baseIndent).AppendLine("}"); // end method
        }

        private string GetParseExpression(Parser.CsvPropertyDefinition prop, string indexVarName)
        {
            string spanAccess = $"row[{indexVarName}].Span";
            if (prop.IsDateTime)
            {
                return $"global::System.DateTime.ParseExact({spanAccess}, \"{prop.DateFormat}\", CultureInfo.InvariantCulture)";
            }
            if (prop.IsString)
            {
                return $"{spanAccess}.ToString()";
            }
            // Assumed ISpanParsable or similar static Parse for others
            return $"{prop.UnderlyingTypeName}.Parse({spanAccess}, CultureInfo.InvariantCulture)";
        }
    }
}
