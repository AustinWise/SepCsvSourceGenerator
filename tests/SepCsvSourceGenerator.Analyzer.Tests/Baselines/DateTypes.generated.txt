// <auto-generated/>
#nullable enable
using nietras.SeparatedValues;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Test
{
    public partial class MyRecord
    {
        public static async partial global::System.Collections.Generic.IAsyncEnumerable<global::Test.MyRecord> ParseRecords(SepReader reader, [EnumeratorCancellation] global::System.Threading.CancellationToken ct)
        {
            int DateNdx;
            int TimeNdx;
            int DtoNdx;

            if (!reader.Header.TryIndexOf("Date", out DateNdx))
            {
                DateNdx = -1;
            }
            if (!reader.Header.TryIndexOf("Time", out TimeNdx))
            {
                TimeNdx = -1;
            }
            if (!reader.Header.TryIndexOf("DateTimeOffset", out DtoNdx))
            {
                DtoNdx = -1;
            }

            await foreach (SepReader.Row row in reader
                #if NET10_0_OR_GREATER
                .WithCancellation(ct).ConfigureAwait(false)
                #endif
            )
            {
                ct.ThrowIfCancellationRequested();

                global::Test.MyRecord ret = new global::Test.MyRecord();
                if (DateNdx != -1)
                {
                    ret.Date = global::System.DateOnly.ParseExact(row[DateNdx].Span, "yyyy-MM-dd", CultureInfo.InvariantCulture);
                }
                if (TimeNdx != -1)
                {
                    ret.Time = global::System.TimeOnly.ParseExact(row[TimeNdx].Span, "HH:mm:ss", CultureInfo.InvariantCulture);
                }
                if (DtoNdx != -1)
                {
                    ret.Dto = global::System.DateTimeOffset.ParseExact(row[DtoNdx].Span, "o", CultureInfo.InvariantCulture);
                }
                yield return ret;
            }
        }
    }
}
